{"ast":null,"code":"import { EventDispatcher, Object3D, Raycaster, Vector2 } from 'three';\n/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\n\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\n\n\nvar Utils = {\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: function () {\n    var ks = _rt(function () {});\n\n    return function (variable) {\n      return _rt(variable) === ks;\n    };\n  }(),\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined: function isUndefined(variable) {\n    return typeof variable === 'undefined';\n  }\n};\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\n\nEventDispatcher.prototype.on = function (type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  if (this instanceof Object3D) this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\n\n\nEventDispatcher.prototype.off = function (type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\n\n\nEventDispatcher.prototype.once = function (type, fn) {\n  var _this = this;\n\n  if (!Utils.isFunction(fn)) return;\n\n  var cb = function cb(ev) {\n    fn(ev);\n\n    _this.off(type, cb);\n  };\n\n  this.on(type, cb);\n  return this;\n};\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @return {this} this\n */\n\n\nEventDispatcher.prototype.emit = function (type) {\n  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n  var cbs = this._listeners[type] || [];\n  var cache = cbs.slice(0);\n\n  for (var _len = arguments.length, argument = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    argument[_key - 1] = arguments[_key];\n  }\n\n  for (var i = 0; i < cache.length; i++) {\n    cache[i].apply(this, argument);\n  }\n\n  return this;\n};\n/**\n * whether displayObject is interactively\n */\n\n\nObject3D.prototype.interactive = false;\n/**\n * whether displayObject's children is interactively\n */\n\nObject3D.prototype.interactiveChildren = true;\n/**\n * whether displayObject had touchstart\n * @private\n */\n\nObject3D.prototype.started = false;\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\n\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get: function get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  }\n});\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\n\nObject3D.prototype.raycastTest = function (raycaster) {\n  var result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\n\n\nvar InteractionData = function () {\n  /**\n   * InteractionData constructor\n   */\n  function InteractionData() {\n    classCallCheck(this, InteractionData);\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n\n    this.global = new Vector2();\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n\n    this.target = null;\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n\n    this.originalEvent = null;\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n\n    this.identifier = null;\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n\n    this.isPrimary = false;\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n\n    this.button = 0;\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n\n    this.buttons = 0;\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n\n    this.width = 0;\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n\n    this.height = 0;\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n\n    this.tiltX = 0;\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n\n    this.tiltY = 0;\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n\n    this.pointerType = null;\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n\n    this.pressure = 0;\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n\n    this.rotationAngle = 0;\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n\n    this.twist = 0;\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n\n    this.tangentialPressure = 0;\n  }\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n\n\n  createClass(InteractionData, [{\n    key: '_copyEvent',\n\n    /**\n     * Copies properties from normalized event data.\n     *\n     * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n     * @private\n     */\n    value: function _copyEvent(event) {\n      // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n      // it with \"false\" on later events when our shim for it on touch events might not be\n      // accurate\n      if (event.isPrimary) {\n        this.isPrimary = true;\n      }\n\n      this.button = event.button;\n      this.buttons = event.buttons;\n      this.width = event.width;\n      this.height = event.height;\n      this.tiltX = event.tiltX;\n      this.tiltY = event.tiltY;\n      this.pointerType = event.pointerType;\n      this.pressure = event.pressure;\n      this.rotationAngle = event.rotationAngle;\n      this.twist = event.twist || 0;\n      this.tangentialPressure = event.tangentialPressure || 0;\n    }\n    /**\n     * Resets the data for pooling.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_reset',\n    value: function _reset() {\n      // isPrimary is the only property that we really need to reset - everything else is\n      // guaranteed to be overwritten\n      this.isPrimary = false;\n    }\n  }, {\n    key: 'pointerId',\n    get: function get$$1() {\n      return this.identifier;\n    }\n  }]);\n  return InteractionData;\n}();\n/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\n\n\nvar InteractionEvent = function () {\n  /**\n   * InteractionEvent constructor\n   */\n  function InteractionEvent() {\n    classCallCheck(this, InteractionEvent);\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n\n    this.stopped = false;\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n\n    this.target = null;\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n\n    this.currentTarget = null;\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n\n    this.type = null;\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n\n    this.data = null;\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersects}\n     */\n\n    this.intersects = [];\n  }\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n\n\n  createClass(InteractionEvent, [{\n    key: \"stopPropagation\",\n    value: function stopPropagation() {\n      this.stopped = true;\n    }\n    /**\n     * Resets the event.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this.stopped = false;\n      this.currentTarget = null;\n      this.target = null;\n      this.intersects = [];\n    }\n  }]);\n  return InteractionEvent;\n}();\n/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\n\n\nvar InteractionTrackingData = function () {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  function InteractionTrackingData(pointerId) {\n    classCallCheck(this, InteractionTrackingData);\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n\n\n  createClass(InteractionTrackingData, [{\n    key: \"_doSet\",\n    value: function _doSet(flag, yn) {\n      if (yn) {\n        this._flags = this._flags | flag;\n      } else {\n        this._flags = this._flags & ~flag;\n      }\n    }\n    /**\n     * Unique pointer id of the event\n     *\n     * @readonly\n     * @member {number}\n     */\n\n  }, {\n    key: \"pointerId\",\n    get: function get$$1() {\n      return this._pointerId;\n    }\n    /**\n     * State of the tracking data, expressed as bit flags\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: \"flags\",\n    get: function get$$1() {\n      return this._flags;\n    }\n    /**\n     * Set the flags for the tracking data\n     *\n     * @param {number} flags - Flags to set\n     */\n    ,\n    set: function set$$1(flags) {\n      this._flags = flags;\n    }\n    /**\n     * Is the tracked event inactive (not over or down)?\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: \"none\",\n    get: function get$$1() {\n      return this._flags === this.constructor.FLAGS.NONE;\n    }\n    /**\n     * Is the tracked event over the DisplayObject?\n     *\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"over\",\n    get: function get$$1() {\n      return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n    }\n    /**\n     * Set the over flag\n     *\n     * @param {boolean} yn - Is the event over?\n     */\n    ,\n    set: function set$$1(yn) {\n      this._doSet(this.constructor.FLAGS.OVER, yn);\n    }\n    /**\n     * Did the right mouse button come down in the DisplayObject?\n     *\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"rightDown\",\n    get: function get$$1() {\n      return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n    }\n    /**\n     * Set the right down flag\n     *\n     * @param {boolean} yn - Is the right mouse button down?\n     */\n    ,\n    set: function set$$1(yn) {\n      this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n    }\n    /**\n     * Did the left mouse button come down in the DisplayObject?\n     *\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"leftDown\",\n    get: function get$$1() {\n      return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n    }\n    /**\n     * Set the left down flag\n     *\n     * @param {boolean} yn - Is the left mouse button down?\n     */\n    ,\n    set: function set$$1(yn) {\n      this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n    }\n  }]);\n  return InteractionTrackingData;\n}();\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2\n});\nvar MOUSE_POINTER_ID = 'MOUSE'; // helpers for hitTest() - only used inside hitTest()\n\nvar hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n};\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\n\nvar InteractionManager = function (_EventDispatcher) {\n  inherits(InteractionManager, _EventDispatcher);\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n\n  function InteractionManager(renderer, scene, camera, options) {\n    classCallCheck(this, InteractionManager);\n\n    var _this = possibleConstructorReturn(this, (InteractionManager.__proto__ || Object.getPrototypeOf(InteractionManager)).call(this));\n\n    options = options || {};\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n\n    _this.renderer = renderer;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n\n    _this.scene = scene;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n\n    _this.camera = camera;\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    _this.autoPreventDefault = options.autoPreventDefault || false;\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n\n    _this.interactionFrequency = options.interactionFrequency || 10;\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n\n    _this.mouse = new InteractionData();\n    _this.mouse.identifier = MOUSE_POINTER_ID; // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n\n    _this.mouse.global.set(-999999);\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n\n\n    _this.activeInteractionData = {};\n    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n\n    _this.interactionDataPool = [];\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n\n    _this.eventData = new InteractionEvent();\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n\n    _this.interactionDOMElement = null;\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    _this.moveWhenInside = true;\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.eventsAdded = false;\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.mouseOverRenderer = false;\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsTouchEvents = 'ontouchstart' in window;\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsPointerEvents = !!window.PointerEvent; // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onClick = _this.onClick.bind(_this);\n    _this.processClick = _this.processClick.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerUp = _this.onPointerUp.bind(_this);\n    _this.processPointerUp = _this.processPointerUp.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerCancel = _this.onPointerCancel.bind(_this);\n    _this.processPointerCancel = _this.processPointerCancel.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerDown = _this.onPointerDown.bind(_this);\n    _this.processPointerDown = _this.processPointerDown.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerMove = _this.onPointerMove.bind(_this);\n    _this.processPointerMove = _this.processPointerMove.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOut = _this.onPointerOut.bind(_this);\n    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOver = _this.onPointerOver.bind(_this);\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n\n    _this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer'\n    };\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n\n    _this.currentCursorMode = null;\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n\n    _this.cursor = null;\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n\n    _this.raycaster = new Raycaster();\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n\n    _this._deltaTime = 0;\n\n    _this.setTargetElement(_this.renderer.domElement);\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n\n    return _this;\n  }\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n\n\n  createClass(InteractionManager, [{\n    key: 'hitTest',\n    value: function hitTest(globalPoint, root) {\n      // clear the target for our hit test\n      hitTestEvent.target = null; // assign the global point\n\n      hitTestEvent.data.global = globalPoint; // ensure safety of the root\n\n      if (!root) {\n        root = this.scene;\n      } // run the hit test\n\n\n      this.processInteractive(hitTestEvent, root, null, true); // return our found object - it'll be null if we didn't hit anything\n\n      return hitTestEvent.target;\n    }\n    /**\n     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n     * another DOM element to receive those events.\n     *\n     * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n     */\n\n  }, {\n    key: 'setTargetElement',\n    value: function setTargetElement(element) {\n      this.removeEvents();\n      this.interactionDOMElement = element;\n      this.addEvents();\n    }\n    /**\n     * Registers all the DOM events\n     *\n     * @private\n     */\n\n  }, {\n    key: 'addEvents',\n    value: function addEvents() {\n      if (!this.interactionDOMElement || this.eventsAdded) {\n        return;\n      }\n\n      this.emit('addevents');\n      this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n        this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = 'none';\n      }\n      /**\n       * These events are added first, so that if pointer events are normalised, they are fired\n       * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n       */\n\n\n      if (this.supportsPointerEvents) {\n        window.document.addEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true); // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n        // we already handle those, so for the purposes of what we do in onPointerOut, we only\n        // care about the pointerleave event\n\n        this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n        window.addEventListener('pointercancel', this.onPointerCancel, true);\n        window.addEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.addEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n        window.addEventListener('mouseup', this.onPointerUp, true);\n      } // always look directly for touch events so that we can provide original data\n      // In a future version we should change this to being just a fallback and rely solely on\n      // PointerEvents whenever available\n\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.eventsAdded = true;\n    }\n    /**\n     * Removes all the DOM events that were previously registered\n     *\n     * @private\n     */\n\n  }, {\n    key: 'removeEvents',\n    value: function removeEvents() {\n      if (!this.interactionDOMElement) {\n        return;\n      }\n\n      this.emit('removeevents');\n      this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = '';\n        this.interactionDOMElement.style['-ms-touch-action'] = '';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = '';\n      }\n\n      if (this.supportsPointerEvents) {\n        window.document.removeEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n        window.removeEventListener('pointercancel', this.onPointerCancel, true);\n        window.removeEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.removeEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n        window.removeEventListener('mouseup', this.onPointerUp, true);\n      }\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.interactionDOMElement = null;\n      this.eventsAdded = false;\n    }\n    /**\n     * Updates the state of interactive objects.\n     * Invoked by a throttled ticker.\n     *\n     * @param {number} deltaTime - time delta since last tick\n     */\n\n  }, {\n    key: 'update',\n    value: function update(_ref) {\n      var snippet = _ref.snippet;\n      this._deltaTime += snippet;\n\n      if (this._deltaTime < this.interactionFrequency) {\n        return;\n      }\n\n      this._deltaTime = 0;\n\n      if (!this.interactionDOMElement) {\n        return;\n      } // if the user move the mouse this check has already been done using the mouse move!\n\n\n      if (this.didMove) {\n        this.didMove = false;\n        return;\n      }\n\n      this.cursor = null; // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n      // but there was a scenario of a display object moving under a static mouse cursor.\n      // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n\n      for (var k in this.activeInteractionData) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (this.activeInteractionData.hasOwnProperty(k)) {\n          var interactionData = this.activeInteractionData[k];\n\n          if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n            this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, true);\n          }\n        }\n      }\n\n      this.setCursorMode(this.cursor); // TODO\n    }\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     *\n     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n     */\n\n  }, {\n    key: 'setCursorMode',\n    value: function setCursorMode(mode) {\n      mode = mode || 'default'; // if the mode didn't actually change, bail early\n\n      if (this.currentCursorMode === mode) {\n        return;\n      }\n\n      this.currentCursorMode = mode;\n      var style = this.cursorStyles[mode]; // only do things if there is a cursor style for it\n\n      if (style) {\n        switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {\n          case 'string':\n            // string styles are handled as cursor CSS\n            this.interactionDOMElement.style.cursor = style;\n            break;\n\n          case 'function':\n            // functions are just called, and passed the cursor mode\n            style(mode);\n            break;\n\n          case 'object':\n            // if it is an object, assume that it is a dictionary of CSS styles,\n            // apply it to the interactionDOMElement\n            Object.assign(this.interactionDOMElement.style, style);\n            break;\n\n          default:\n            break;\n        }\n      } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n        // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n        // for the mode, then assume that the dev wants it to be CSS for the cursor.\n        this.interactionDOMElement.style.cursor = mode;\n      }\n    }\n    /**\n     * Dispatches an event on the display object that was interacted with\n     *\n     * @param {Object3D} displayObject - the display object in question\n     * @param {string} eventString - the name of the event (e.g, mousedown)\n     * @param {object} eventData - the event data object\n     * @private\n     */\n\n  }, {\n    key: 'triggerEvent',\n    value: function triggerEvent(displayObject, eventString, eventData) {\n      if (!eventData.stopped) {\n        eventData.currentTarget = displayObject;\n        eventData.type = eventString;\n        displayObject.emit(eventString, eventData);\n\n        if (displayObject[eventString]) {\n          displayObject[eventString](eventData);\n        }\n      }\n    }\n    /**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param {Object3D} displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param {Function} [func] - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n     * @param {boolean} [interactive] - Whether the displayObject is interactive\n     * @return {boolean} returns true if the displayObject hit the point\n     */\n\n  }, {\n    key: 'processInteractive',\n    value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n      if (!displayObject || !displayObject.visible) {\n        return false;\n      } // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n      //\n      // This function will now loop through all objects and then only hit test the objects it HAS\n      // to, not all of them. MUCH faster..\n      // An object will be hit test if the following is true:\n      //\n      // 1: It is interactive.\n      // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n      //\n      // As another little optimisation once an interactive object has been hit we can carry on\n      // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n      // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n\n      interactive = displayObject.interactive || interactive;\n      var hit = false;\n      var interactiveParent = interactive;\n\n      if (displayObject.interactiveChildren && displayObject.children) {\n        var children = displayObject.children;\n\n        for (var i = children.length - 1; i >= 0; i--) {\n          var child = children[i]; // time to get recursive.. if this function will return if something is hit..\n\n          var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n          if (childHit) {\n            // its a good idea to check if a child has lost its parent.\n            // this means it has been removed whilst looping so its best\n            if (!child.parent) {\n              continue;\n            } // we no longer need to hit test any more objects in this container as we we\n            // now know the parent has been hit\n\n\n            interactiveParent = false; // If the child is interactive , that means that the object hit was actually\n            // interactive and not just the child of an interactive object.\n            // This means we no longer need to hit test anything else. We still need to run\n            // through all objects, but we don't need to perform any hit tests.\n\n            if (childHit) {\n              if (interactionEvent.target) {\n                hitTest = false;\n              }\n\n              hit = true;\n            }\n          }\n        }\n      } // no point running this if the item is not interactive or does not have an interactive parent.\n\n\n      if (interactive) {\n        // if we are hit testing (as in we have no hit any objects yet)\n        // We also don't need to worry about hit testing if once of the displayObjects children\n        // has already been hit - but only if it was interactive, otherwise we need to keep\n        // looking for an interactive child, just in case we hit one\n        if (hitTest && !interactionEvent.target) {\n          if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n            hit = true;\n          }\n        }\n\n        if (displayObject.interactive) {\n          if (hit && !interactionEvent.target) {\n            interactionEvent.data.target = interactionEvent.target = displayObject;\n          }\n\n          if (func) {\n            func(interactionEvent, displayObject, !!hit);\n          }\n        }\n      }\n\n      return hit;\n    }\n    /**\n     * Is called when the click is pressed down on the renderer element\n     *\n     * @private\n     * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n     */\n\n  }, {\n    key: 'onClick',\n    value: function onClick(originalEvent) {\n      if (originalEvent.type !== 'click') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(events[0]);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n      this.emit('click', interactionEvent);\n    }\n    /**\n     * Processes the result of the click check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processClick',\n    value: function processClick(interactionEvent, displayObject, hit) {\n      if (hit) {\n        this.triggerEvent(displayObject, 'click', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer button is pressed down on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n     */\n\n  }, {\n    key: 'onPointerDown',\n    value: function onPointerDown(originalEvent) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n      /**\n       * No need to prevent default on natural pointer events, as there are no side effects\n       * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n       * so still need to be prevented.\n       */\n      // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n        this.emit('pointerdown', interactionEvent);\n\n        if (event.pointerType === 'touch') {\n          this.emit('touchstart', interactionEvent);\n        } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n        }\n      }\n    }\n    /**\n     * Processes the result of the pointer down check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerDown',\n    value: function processPointerDown(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (hit) {\n        if (!displayObject.trackedPointers[id]) {\n          displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n        }\n\n        this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          displayObject.started = true;\n          this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n        } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n          var isRightButton = data.button === 2;\n\n          if (isRightButton) {\n            displayObject.trackedPointers[id].rightDown = true;\n          } else {\n            displayObject.trackedPointers[id].leftDown = true;\n          }\n\n          this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n     * @param {boolean} cancelled - true if the pointer is cancelled\n     * @param {Function} func - Function passed to {@link processInteractive}\n     */\n\n  }, {\n    key: 'onPointerComplete',\n    value: function onPointerComplete(originalEvent, cancelled, func) {\n      var events = this.normalizeToPointerData(originalEvent);\n      var eventLen = events.length; // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n      // in all cases (unless it was a pointercancel)\n\n      var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent; // perform hit testing for events targeting our canvas or cancel events\n\n        this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n        this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);\n\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);\n        } else if (event.pointerType === 'touch') {\n          this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);\n          this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is cancelled\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerCancel',\n    value: function onPointerCancel(event) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, true, this.processPointerCancel);\n    }\n    /**\n     * Processes the result of the pointer cancel check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     */\n\n  }, {\n    key: 'processPointerCancel',\n    value: function processPointerCancel(interactionEvent, displayObject) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (displayObject.trackedPointers[id] !== undefined) {\n        delete displayObject.trackedPointers[id];\n        this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerUp',\n    value: function onPointerUp(event) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, false, this.processPointerUp);\n    }\n    /**\n     * Processes the result of the pointer up check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerUp',\n    value: function processPointerUp(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var trackingData = displayObject.trackedPointers[id];\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; // Mouse only\n\n      if (isMouse) {\n        var isRightButton = data.button === 2;\n        var flags = InteractionTrackingData.FLAGS;\n        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n        var isDown = trackingData !== undefined && trackingData.flags & test;\n\n        if (hit) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n          if (isDown) {\n            this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n          }\n        } else if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n        } // update the down state of the tracking data\n\n\n        if (trackingData) {\n          if (isRightButton) {\n            trackingData.rightDown = false;\n          } else {\n            trackingData.leftDown = false;\n          }\n        }\n      } // Pointers and Touches, and Mouse\n\n\n      if (isTouch && displayObject.started) {\n        displayObject.started = false;\n        this.triggerEvent(displayObject, 'touchend', interactionEvent);\n      }\n\n      if (hit) {\n        this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n        if (trackingData) {\n          this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n\n          if (isTouch) {\n            this.triggerEvent(displayObject, 'tap', interactionEvent); // touches are no longer over (if they ever were) when we get the touchend\n            // so we should ensure that we don't keep pretending that they are\n\n            trackingData.over = false;\n          }\n        }\n      } else if (trackingData) {\n        this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n        if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n      } // Only remove the tracking data if there is no over/down state still associated with it\n\n\n      if (trackingData && trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n    /**\n     * Is called when the pointer moves across the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n     */\n\n  }, {\n    key: 'onPointerMove',\n    value: function onPointerMove(originalEvent) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (events[0].pointerType === 'mouse') {\n        this.didMove = true;\n        this.cursor = null;\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n        this.processInteractive(interactionEvent, this.scene, this.processPointerMove, interactive);\n        this.emit('pointermove', interactionEvent);\n        if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n      }\n\n      if (events[0].pointerType === 'mouse') {\n        this.setCursorMode(this.cursor); // TODO BUG for parents interactive object (border order issue)\n      }\n    }\n    /**\n     * Processes the result of the pointer move check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerMove',\n    value: function processPointerMove(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n\n      if (isMouse) {\n        this.processPointerOverOut(interactionEvent, displayObject, hit);\n      }\n\n      if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n\n      if (!this.moveWhenInside || hit) {\n        this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n        if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer is moved out of the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n     */\n\n  }, {\n    key: 'onPointerOut',\n    value: function onPointerOut(originalEvent) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOut, so events will always be length 1\n\n      var event = events[0];\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = false;\n        this.setCursorMode(null);\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n      this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n      this.emit('pointerout', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseout', interactionEvent);\n      } else {\n        // we can get touchleave events after touchend, so we want to make sure we don't\n        // introduce memory leaks\n        this.releaseInteractionDataForPointerId(interactionData.identifier);\n      }\n    }\n    /**\n     * Processes the result of the pointer over/out check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerOverOut',\n    value: function processPointerOverOut(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n      var trackingData = displayObject.trackedPointers[id]; // if we just moused over the display object, then we need to track that state\n\n      if (hit && !trackingData) {\n        trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n\n      if (trackingData === undefined) return;\n\n      if (hit && this.mouseOverRenderer) {\n        if (!trackingData.over) {\n          trackingData.over = true;\n          this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n\n          if (isMouse) {\n            this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n          }\n        } // only change the cursor if it has not already been changed (by something deeper in the\n        // display tree)\n\n\n        if (isMouse && this.cursor === null) {\n          this.cursor = displayObject.cursor;\n        }\n      } else if (trackingData.over) {\n        trackingData.over = false;\n        this.triggerEvent(displayObject, 'pointerout', this.eventData);\n\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n        } // if there is no mouse down information for the pointer, then it is safe to delete\n\n\n        if (trackingData.none) {\n          delete displayObject.trackedPointers[id];\n        }\n      }\n    }\n    /**\n     * Is called when the pointer is moved into the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n     */\n\n  }, {\n    key: 'onPointerOver',\n    value: function onPointerOver(originalEvent) {\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOver, so events will always be length 1\n\n      var event = events[0];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = true;\n      }\n\n      this.emit('pointerover', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseover', interactionEvent);\n      }\n    }\n    /**\n     * Get InteractionData for a given pointerId. Store that data as well\n     *\n     * @private\n     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n     * @return {InteractionData} - Interaction data for the given pointer identifier\n     */\n\n  }, {\n    key: 'getInteractionDataForPointerId',\n    value: function getInteractionDataForPointerId(event) {\n      var pointerId = event.pointerId;\n      var interactionData = void 0;\n\n      if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n        interactionData = this.mouse;\n      } else if (this.activeInteractionData[pointerId]) {\n        interactionData = this.activeInteractionData[pointerId];\n      } else {\n        interactionData = this.interactionDataPool.pop() || new InteractionData();\n        interactionData.identifier = pointerId;\n        this.activeInteractionData[pointerId] = interactionData;\n      } // copy properties from the event, so that we can make sure that touch/pointer specific\n      // data is available\n\n\n      interactionData._copyEvent(event);\n\n      return interactionData;\n    }\n    /**\n     * Return unused InteractionData to the pool, for a given pointerId\n     *\n     * @private\n     * @param {number} pointerId - Identifier from a pointer event\n     */\n\n  }, {\n    key: 'releaseInteractionDataForPointerId',\n    value: function releaseInteractionDataForPointerId(pointerId) {\n      var interactionData = this.activeInteractionData[pointerId];\n\n      if (interactionData) {\n        delete this.activeInteractionData[pointerId];\n\n        interactionData._reset();\n\n        this.interactionDataPool.push(interactionData);\n      }\n    }\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     *\n     * @param  {Vector2} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n\n  }, {\n    key: 'mapPositionToPoint',\n    value: function mapPositionToPoint(point, x, y) {\n      var rect = void 0; // IE 11 fix\n\n      if (!this.interactionDOMElement.parentElement) {\n        rect = {\n          x: 0,\n          y: 0,\n          left: 0,\n          top: 0,\n          width: 0,\n          height: 0\n        };\n      } else {\n        rect = this.interactionDOMElement.getBoundingClientRect();\n      }\n\n      point.x = (x - rect.left) / rect.width * 2 - 1;\n      point.y = -((y - rect.top) / rect.height) * 2 + 1;\n    }\n    /**\n     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The event to be configured\n     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n     * @param {InteractionData} interactionData - The InteractionData that will be paired\n     *        with the InteractionEvent\n     * @return {InteractionEvent} the interaction event that was passed in\n     */\n\n  }, {\n    key: 'configureInteractionEventForDOMEvent',\n    value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n      interactionEvent.data = interactionData;\n      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n      this.raycaster.setFromCamera(interactionData.global, this.camera); // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n\n      if (pointerEvent.pointerType === 'touch') {\n        pointerEvent.globalX = interactionData.global.x;\n        pointerEvent.globalY = interactionData.global.y;\n      }\n\n      interactionData.originalEvent = pointerEvent;\n\n      interactionEvent._reset();\n\n      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n      return interactionEvent;\n    }\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     *\n     * @private\n     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n\n  }, {\n    key: 'normalizeToPointerData',\n    value: function normalizeToPointerData(event) {\n      var normalizedEvents = [];\n\n      if (this.supportsTouchEvents && event instanceof TouchEvent) {\n        for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n          var touch = event.changedTouches[i];\n          if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n          if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n\n          if (typeof touch.isPrimary === 'undefined') {\n            touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n          }\n\n          if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n          if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n          if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n          if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n          if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n          if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n          if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n          touch.twist = 0;\n          touch.tangentialPressure = 0; // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n          // support, and the fill ins are not quite the same\n          // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n          // left is not 0,0 on the page\n\n          if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n          if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY; // mark the touch as normalized, just so that we know we did it\n\n          touch.isNormalized = true;\n          normalizedEvents.push(touch);\n        }\n      } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n        if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n        if (typeof event.width === 'undefined') event.width = 1;\n        if (typeof event.height === 'undefined') event.height = 1;\n        if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n        if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n        if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n        if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n        if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n        event.twist = 0;\n        event.tangentialPressure = 0; // mark the mouse event as normalized, just so that we know we did it\n\n        event.isNormalized = true;\n        normalizedEvents.push(event);\n      } else {\n        normalizedEvents.push(event);\n      }\n\n      return normalizedEvents;\n    }\n    /**\n     * Destroys the interaction manager\n     *\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.removeEvents();\n      this.removeAllListeners();\n      this.renderer = null;\n      this.mouse = null;\n      this.eventData = null;\n      this.interactionDOMElement = null;\n      this.onPointerDown = null;\n      this.processPointerDown = null;\n      this.onPointerUp = null;\n      this.processPointerUp = null;\n      this.onPointerCancel = null;\n      this.processPointerCancel = null;\n      this.onPointerMove = null;\n      this.processPointerMove = null;\n      this.onPointerOut = null;\n      this.processPointerOverOut = null;\n      this.onPointerOver = null;\n      this._tempPoint = null;\n    }\n  }]);\n  return InteractionManager;\n}(EventDispatcher);\n\nvar MOUSE_POINTER_ID$1 = 'MOUSE'; // helpers for hitTest() - only used inside hitTest()\n\nvar hitTestEvent$1 = {\n  target: null,\n  data: {\n    global: null\n  }\n};\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\n\nvar InteractionLayer = function (_EventDispatcher) {\n  inherits(InteractionLayer, _EventDispatcher);\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n\n  function InteractionLayer(renderer, options) {\n    classCallCheck(this, InteractionLayer);\n\n    var _this = possibleConstructorReturn(this, (InteractionLayer.__proto__ || Object.getPrototypeOf(InteractionLayer)).call(this));\n\n    options = options || {};\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n\n    _this.renderer = renderer;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Layer}\n     */\n\n    _this.layer = null;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    // this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    // this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    _this.autoPreventDefault = options.autoPreventDefault || false;\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n\n    _this.interactionFrequency = options.interactionFrequency || 10;\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n\n    _this.mouse = new InteractionData();\n    _this.mouse.identifier = MOUSE_POINTER_ID$1; // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n\n    _this.mouse.global.set(-999999);\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n\n\n    _this.activeInteractionData = {};\n    _this.activeInteractionData[MOUSE_POINTER_ID$1] = _this.mouse;\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n\n    _this.interactionDataPool = [];\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n\n    _this.eventData = new InteractionEvent();\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n\n    _this.interactionDOMElement = null;\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    _this.moveWhenInside = true;\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.eventsAdded = false;\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.mouseOverRenderer = false;\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsTouchEvents = 'ontouchstart' in window;\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsPointerEvents = !!window.PointerEvent; // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onClick = _this.onClick.bind(_this);\n    _this.processClick = _this.processClick.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerUp = _this.onPointerUp.bind(_this);\n    _this.processPointerUp = _this.processPointerUp.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerCancel = _this.onPointerCancel.bind(_this);\n    _this.processPointerCancel = _this.processPointerCancel.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerDown = _this.onPointerDown.bind(_this);\n    _this.processPointerDown = _this.processPointerDown.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerMove = _this.onPointerMove.bind(_this);\n    _this.processPointerMove = _this.processPointerMove.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOut = _this.onPointerOut.bind(_this);\n    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOver = _this.onPointerOver.bind(_this);\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n\n    _this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer'\n    };\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n\n    _this.currentCursorMode = null;\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n\n    _this.cursor = null;\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n\n    _this.raycaster = new Raycaster();\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n\n    _this._deltaTime = 0;\n\n    _this.setTargetElement(_this.renderer.domElement);\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionLayer#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionLayer#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionLayer#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionLayer#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionLayer#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionLayer#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionLayer#event:mousedown}.\n     *\n     * @event InteractionLayer#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionLayer#event:rightdown}.\n     *\n     * @event InteractionLayer#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionLayer#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionLayer#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionLayer#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionLayer#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionLayer#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionLayer#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionLayer#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.\n     *\n     * @event InteractionLayer#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionLayer#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionLayer#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionLayer#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionLayer#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionLayer#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionLayer#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionLayer#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionLayer#event:touchstart}.\n     *\n     * @event InteractionLayer#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionLayer#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n\n    return _this;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  createClass(InteractionLayer, [{\n    key: 'isAble',\n    value: function isAble() {\n      return this.layer && this.layer.interactive;\n    }\n    /**\n     * set layer\n     * @param {Layer} layer layer\n     */\n\n  }, {\n    key: 'setLayer',\n    value: function setLayer(layer) {\n      this.layer = layer;\n    }\n    /**\n     * Hit tests a point against the display tree, returning the first interactive object that is hit.\n     *\n     * @param {Point} globalPoint - A point to hit test with, in global space.\n     * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n     * to the last rendered root of the associated renderer.\n     * @return {Object3D} The hit display object, if any.\n     */\n\n  }, {\n    key: 'hitTest',\n    value: function hitTest(globalPoint, root) {\n      if (!this.isAble()) return null; // clear the target for our hit test\n\n      hitTestEvent$1.target = null; // assign the global point\n\n      hitTestEvent$1.data.global = globalPoint; // ensure safety of the root\n\n      if (!root) {\n        root = this.layer.scene;\n      } // run the hit test\n\n\n      this.processInteractive(hitTestEvent$1, root, null, true); // return our found object - it'll be null if we didn't hit anything\n\n      return hitTestEvent$1.target;\n    }\n    /**\n     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n     * another DOM element to receive those events.\n     *\n     * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n     */\n\n  }, {\n    key: 'setTargetElement',\n    value: function setTargetElement(element) {\n      this.removeEvents();\n      this.interactionDOMElement = element;\n      this.addEvents();\n    }\n    /**\n     * Registers all the DOM events\n     *\n     * @private\n     */\n\n  }, {\n    key: 'addEvents',\n    value: function addEvents() {\n      if (!this.interactionDOMElement || this.eventsAdded) {\n        return;\n      }\n\n      this.emit('addevents');\n      this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n        this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = 'none';\n      }\n      /**\n       * These events are added first, so that if pointer events are normalised, they are fired\n       * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n       */\n\n\n      if (this.supportsPointerEvents) {\n        window.document.addEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true); // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n        // we already handle those, so for the purposes of what we do in onPointerOut, we only\n        // care about the pointerleave event\n\n        this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n        window.addEventListener('pointercancel', this.onPointerCancel, true);\n        window.addEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.addEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n        window.addEventListener('mouseup', this.onPointerUp, true);\n      } // always look directly for touch events so that we can provide original data\n      // In a future version we should change this to being just a fallback and rely solely on\n      // PointerEvents whenever available\n\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.eventsAdded = true;\n    }\n    /**\n     * Removes all the DOM events that were previously registered\n     *\n     * @private\n     */\n\n  }, {\n    key: 'removeEvents',\n    value: function removeEvents() {\n      if (!this.interactionDOMElement) {\n        return;\n      }\n\n      this.emit('removeevents');\n      this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = '';\n        this.interactionDOMElement.style['-ms-touch-action'] = '';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = '';\n      }\n\n      if (this.supportsPointerEvents) {\n        window.document.removeEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n        window.removeEventListener('pointercancel', this.onPointerCancel, true);\n        window.removeEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.removeEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n        window.removeEventListener('mouseup', this.onPointerUp, true);\n      }\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.interactionDOMElement = null;\n      this.eventsAdded = false;\n    }\n    /**\n     * Updates the state of interactive objects.\n     * Invoked by a throttled ticker.\n     *\n     * @param {number} deltaTime - time delta since last tick\n     */\n\n  }, {\n    key: 'update',\n    value: function update(_ref) {\n      var snippet = _ref.snippet;\n      if (!this.isAble()) return;\n      this._deltaTime += snippet;\n\n      if (this._deltaTime < this.interactionFrequency) {\n        return;\n      }\n\n      this._deltaTime = 0;\n\n      if (!this.interactionDOMElement) {\n        return;\n      } // if the user move the mouse this check has already been done using the mouse move!\n\n\n      if (this.didMove) {\n        this.didMove = false;\n        return;\n      }\n\n      this.cursor = null; // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n      // but there was a scenario of a display object moving under a static mouse cursor.\n      // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n\n      for (var k in this.activeInteractionData) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (this.activeInteractionData.hasOwnProperty(k)) {\n          var interactionData = this.activeInteractionData[k];\n\n          if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n            this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, true);\n          }\n        }\n      }\n\n      this.setCursorMode(this.cursor); // TODO\n    }\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     *\n     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n     */\n\n  }, {\n    key: 'setCursorMode',\n    value: function setCursorMode(mode) {\n      mode = mode || 'default'; // if the mode didn't actually change, bail early\n\n      if (this.currentCursorMode === mode) {\n        return;\n      }\n\n      this.currentCursorMode = mode;\n      var style = this.cursorStyles[mode]; // only do things if there is a cursor style for it\n\n      if (style) {\n        switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {\n          case 'string':\n            // string styles are handled as cursor CSS\n            this.interactionDOMElement.style.cursor = style;\n            break;\n\n          case 'function':\n            // functions are just called, and passed the cursor mode\n            style(mode);\n            break;\n\n          case 'object':\n            // if it is an object, assume that it is a dictionary of CSS styles,\n            // apply it to the interactionDOMElement\n            Object.assign(this.interactionDOMElement.style, style);\n            break;\n\n          default:\n            break;\n        }\n      } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n        // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n        // for the mode, then assume that the dev wants it to be CSS for the cursor.\n        this.interactionDOMElement.style.cursor = mode;\n      }\n    }\n    /**\n     * Dispatches an event on the display object that was interacted with\n     *\n     * @param {Object3D} displayObject - the display object in question\n     * @param {string} eventString - the name of the event (e.g, mousedown)\n     * @param {object} eventData - the event data object\n     * @private\n     */\n\n  }, {\n    key: 'triggerEvent',\n    value: function triggerEvent(displayObject, eventString, eventData) {\n      if (!eventData.stopped) {\n        eventData.currentTarget = displayObject;\n        eventData.type = eventString;\n        displayObject.emit(eventString, eventData);\n\n        if (displayObject[eventString]) {\n          displayObject[eventString](eventData);\n        }\n      }\n    }\n    /**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param {Object3D} displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param {Function} [func] - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n     * @param {boolean} [interactive] - Whether the displayObject is interactive\n     * @return {boolean} returns true if the displayObject hit the point\n     */\n\n  }, {\n    key: 'processInteractive',\n    value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n      if (!displayObject || !displayObject.visible) {\n        return false;\n      } // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n      //\n      // This function will now loop through all objects and then only hit test the objects it HAS\n      // to, not all of them. MUCH faster..\n      // An object will be hit test if the following is true:\n      //\n      // 1: It is interactive.\n      // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n      //\n      // As another little optimisation once an interactive object has been hit we can carry on\n      // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n      // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n\n      interactive = displayObject.interactive || interactive;\n      var hit = false;\n      var interactiveParent = interactive;\n\n      if (displayObject.interactiveChildren && displayObject.children) {\n        var children = displayObject.children;\n\n        for (var i = children.length - 1; i >= 0; i--) {\n          var child = children[i]; // time to get recursive.. if this function will return if something is hit..\n\n          var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n          if (childHit) {\n            // its a good idea to check if a child has lost its parent.\n            // this means it has been removed whilst looping so its best\n            if (!child.parent) {\n              continue;\n            } // we no longer need to hit test any more objects in this container as we we\n            // now know the parent has been hit\n\n\n            interactiveParent = false; // If the child is interactive , that means that the object hit was actually\n            // interactive and not just the child of an interactive object.\n            // This means we no longer need to hit test anything else. We still need to run\n            // through all objects, but we don't need to perform any hit tests.\n\n            if (childHit) {\n              if (interactionEvent.target) {\n                hitTest = false;\n              }\n\n              hit = true;\n            }\n          }\n        }\n      } // no point running this if the item is not interactive or does not have an interactive parent.\n\n\n      if (interactive) {\n        // if we are hit testing (as in we have no hit any objects yet)\n        // We also don't need to worry about hit testing if once of the displayObjects children\n        // has already been hit - but only if it was interactive, otherwise we need to keep\n        // looking for an interactive child, just in case we hit one\n        if (hitTest && !interactionEvent.target) {\n          if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n            hit = true;\n          }\n        }\n\n        if (displayObject.interactive) {\n          if (hit && !interactionEvent.target) {\n            interactionEvent.data.target = interactionEvent.target = displayObject;\n          }\n\n          if (func) {\n            func(interactionEvent, displayObject, !!hit);\n          }\n        }\n      }\n\n      return hit;\n    }\n    /**\n     * Is called when the click is pressed down on the renderer element\n     *\n     * @private\n     * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n     */\n\n  }, {\n    key: 'onClick',\n    value: function onClick(originalEvent) {\n      if (!this.isAble()) return;\n      if (originalEvent.type !== 'click') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(events[0]);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);\n      this.emit('click', interactionEvent);\n    }\n    /**\n     * Processes the result of the click check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processClick',\n    value: function processClick(interactionEvent, displayObject, hit) {\n      if (hit) {\n        this.triggerEvent(displayObject, 'click', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer button is pressed down on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n     */\n\n  }, {\n    key: 'onPointerDown',\n    value: function onPointerDown(originalEvent) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n      /**\n       * No need to prevent default on natural pointer events, as there are no side effects\n       * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n       * so still need to be prevented.\n       */\n      // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);\n        this.emit('pointerdown', interactionEvent);\n\n        if (event.pointerType === 'touch') {\n          this.emit('touchstart', interactionEvent);\n        } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n        }\n      }\n    }\n    /**\n     * Processes the result of the pointer down check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerDown',\n    value: function processPointerDown(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (hit) {\n        if (!displayObject.trackedPointers[id]) {\n          displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n        }\n\n        this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          displayObject.started = true;\n          this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n        } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n          var isRightButton = data.button === 2;\n\n          if (isRightButton) {\n            displayObject.trackedPointers[id].rightDown = true;\n          } else {\n            displayObject.trackedPointers[id].leftDown = true;\n          }\n\n          this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n     * @param {boolean} cancelled - true if the pointer is cancelled\n     * @param {Function} func - Function passed to {@link processInteractive}\n     */\n\n  }, {\n    key: 'onPointerComplete',\n    value: function onPointerComplete(originalEvent, cancelled, func) {\n      var events = this.normalizeToPointerData(originalEvent);\n      var eventLen = events.length; // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n      // in all cases (unless it was a pointercancel)\n\n      var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent; // perform hit testing for events targeting our canvas or cancel events\n\n        this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);\n        this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);\n\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);\n        } else if (event.pointerType === 'touch') {\n          this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);\n          this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is cancelled\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerCancel',\n    value: function onPointerCancel(event) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, true, this.processPointerCancel);\n    }\n    /**\n     * Processes the result of the pointer cancel check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     */\n\n  }, {\n    key: 'processPointerCancel',\n    value: function processPointerCancel(interactionEvent, displayObject) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (displayObject.trackedPointers[id] !== undefined) {\n        delete displayObject.trackedPointers[id];\n        this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerUp',\n    value: function onPointerUp(event) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, false, this.processPointerUp);\n    }\n    /**\n     * Processes the result of the pointer up check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerUp',\n    value: function processPointerUp(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var trackingData = displayObject.trackedPointers[id];\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; // Mouse only\n\n      if (isMouse) {\n        var isRightButton = data.button === 2;\n        var flags = InteractionTrackingData.FLAGS;\n        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n        var isDown = trackingData !== undefined && trackingData.flags & test;\n\n        if (hit) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n          if (isDown) {\n            this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n          }\n        } else if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n        } // update the down state of the tracking data\n\n\n        if (trackingData) {\n          if (isRightButton) {\n            trackingData.rightDown = false;\n          } else {\n            trackingData.leftDown = false;\n          }\n        }\n      } // Pointers and Touches, and Mouse\n\n\n      if (isTouch && displayObject.started) {\n        displayObject.started = false;\n        this.triggerEvent(displayObject, 'touchend', interactionEvent);\n      }\n\n      if (hit) {\n        this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n        if (trackingData) {\n          this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n\n          if (isTouch) {\n            this.triggerEvent(displayObject, 'tap', interactionEvent); // touches are no longer over (if they ever were) when we get the touchend\n            // so we should ensure that we don't keep pretending that they are\n\n            trackingData.over = false;\n          }\n        }\n      } else if (trackingData) {\n        this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n        if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n      } // Only remove the tracking data if there is no over/down state still associated with it\n\n\n      if (trackingData && trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n    /**\n     * Is called when the pointer moves across the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n     */\n\n  }, {\n    key: 'onPointerMove',\n    value: function onPointerMove(originalEvent) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (events[0].pointerType === 'mouse') {\n        this.didMove = true;\n        this.cursor = null;\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerMove, interactive);\n        this.emit('pointermove', interactionEvent);\n        if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n      }\n\n      if (events[0].pointerType === 'mouse') {\n        this.setCursorMode(this.cursor); // TODO BUG for parents interactive object (border order issue)\n      }\n    }\n    /**\n     * Processes the result of the pointer move check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerMove',\n    value: function processPointerMove(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n\n      if (isMouse) {\n        this.processPointerOverOut(interactionEvent, displayObject, hit);\n      }\n\n      if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n\n      if (!this.moveWhenInside || hit) {\n        this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n        if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer is moved out of the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n     */\n\n  }, {\n    key: 'onPointerOut',\n    value: function onPointerOut(originalEvent) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOut, so events will always be length 1\n\n      var event = events[0];\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = false;\n        this.setCursorMode(null);\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);\n      this.emit('pointerout', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseout', interactionEvent);\n      } else {\n        // we can get touchleave events after touchend, so we want to make sure we don't\n        // introduce memory leaks\n        this.releaseInteractionDataForPointerId(interactionData.identifier);\n      }\n    }\n    /**\n     * Processes the result of the pointer over/out check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerOverOut',\n    value: function processPointerOverOut(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n      var trackingData = displayObject.trackedPointers[id]; // if we just moused over the display object, then we need to track that state\n\n      if (hit && !trackingData) {\n        trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n\n      if (trackingData === undefined) return;\n\n      if (hit && this.mouseOverRenderer) {\n        if (!trackingData.over) {\n          trackingData.over = true;\n          this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n\n          if (isMouse) {\n            this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n          }\n        } // only change the cursor if it has not already been changed (by something deeper in the\n        // display tree)\n\n\n        if (isMouse && this.cursor === null) {\n          this.cursor = displayObject.cursor;\n        }\n      } else if (trackingData.over) {\n        trackingData.over = false;\n        this.triggerEvent(displayObject, 'pointerout', this.eventData);\n\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n        } // if there is no mouse down information for the pointer, then it is safe to delete\n\n\n        if (trackingData.none) {\n          delete displayObject.trackedPointers[id];\n        }\n      }\n    }\n    /**\n     * Is called when the pointer is moved into the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n     */\n\n  }, {\n    key: 'onPointerOver',\n    value: function onPointerOver(originalEvent) {\n      if (!this.isAble()) return;\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOver, so events will always be length 1\n\n      var event = events[0];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = true;\n      }\n\n      this.emit('pointerover', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseover', interactionEvent);\n      }\n    }\n    /**\n     * Get InteractionData for a given pointerId. Store that data as well\n     *\n     * @private\n     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n     * @return {InteractionData} - Interaction data for the given pointer identifier\n     */\n\n  }, {\n    key: 'getInteractionDataForPointerId',\n    value: function getInteractionDataForPointerId(event) {\n      var pointerId = event.pointerId;\n      var interactionData = void 0;\n\n      if (pointerId === MOUSE_POINTER_ID$1 || event.pointerType === 'mouse') {\n        interactionData = this.mouse;\n      } else if (this.activeInteractionData[pointerId]) {\n        interactionData = this.activeInteractionData[pointerId];\n      } else {\n        interactionData = this.interactionDataPool.pop() || new InteractionData();\n        interactionData.identifier = pointerId;\n        this.activeInteractionData[pointerId] = interactionData;\n      } // copy properties from the event, so that we can make sure that touch/pointer specific\n      // data is available\n\n\n      interactionData._copyEvent(event);\n\n      return interactionData;\n    }\n    /**\n     * Return unused InteractionData to the pool, for a given pointerId\n     *\n     * @private\n     * @param {number} pointerId - Identifier from a pointer event\n     */\n\n  }, {\n    key: 'releaseInteractionDataForPointerId',\n    value: function releaseInteractionDataForPointerId(pointerId) {\n      var interactionData = this.activeInteractionData[pointerId];\n\n      if (interactionData) {\n        delete this.activeInteractionData[pointerId];\n\n        interactionData._reset();\n\n        this.interactionDataPool.push(interactionData);\n      }\n    }\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     *\n     * @param  {Vector2} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n\n  }, {\n    key: 'mapPositionToPoint',\n    value: function mapPositionToPoint(point, x, y) {\n      var rect = void 0; // IE 11 fix\n\n      if (!this.interactionDOMElement.parentElement) {\n        rect = {\n          x: 0,\n          y: 0,\n          left: 0,\n          top: 0,\n          width: 0,\n          height: 0\n        };\n      } else {\n        rect = this.interactionDOMElement.getBoundingClientRect();\n      }\n\n      point.x = (x - rect.left) / rect.width * 2 - 1;\n      point.y = -((y - rect.top) / rect.height) * 2 + 1;\n    }\n    /**\n     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The event to be configured\n     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n     * @param {InteractionData} interactionData - The InteractionData that will be paired\n     *        with the InteractionEvent\n     * @return {InteractionEvent} the interaction event that was passed in\n     */\n\n  }, {\n    key: 'configureInteractionEventForDOMEvent',\n    value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n      interactionEvent.data = interactionData;\n      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n      if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera); // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n\n      if (pointerEvent.pointerType === 'touch') {\n        pointerEvent.globalX = interactionData.global.x;\n        pointerEvent.globalY = interactionData.global.y;\n      }\n\n      interactionData.originalEvent = pointerEvent;\n\n      interactionEvent._reset();\n\n      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n      return interactionEvent;\n    }\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     *\n     * @private\n     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n\n  }, {\n    key: 'normalizeToPointerData',\n    value: function normalizeToPointerData(event) {\n      var normalizedEvents = [];\n\n      if (this.supportsTouchEvents && event instanceof TouchEvent) {\n        for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n          var touch = event.changedTouches[i];\n          if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n          if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n\n          if (typeof touch.isPrimary === 'undefined') {\n            touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n          }\n\n          if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n          if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n          if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n          if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n          if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n          if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n          if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n          touch.twist = 0;\n          touch.tangentialPressure = 0; // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n          // support, and the fill ins are not quite the same\n          // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n          // left is not 0,0 on the page\n\n          if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n          if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY; // mark the touch as normalized, just so that we know we did it\n\n          touch.isNormalized = true;\n          normalizedEvents.push(touch);\n        }\n      } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n        if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n        if (typeof event.width === 'undefined') event.width = 1;\n        if (typeof event.height === 'undefined') event.height = 1;\n        if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n        if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n        if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n        if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID$1;\n        if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n        event.twist = 0;\n        event.tangentialPressure = 0; // mark the mouse event as normalized, just so that we know we did it\n\n        event.isNormalized = true;\n        normalizedEvents.push(event);\n      } else {\n        normalizedEvents.push(event);\n      }\n\n      return normalizedEvents;\n    }\n    /**\n     * Destroys the interaction manager\n     *\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.removeEvents();\n      this.removeAllListeners();\n      this.renderer = null;\n      this.mouse = null;\n      this.eventData = null;\n      this.interactionDOMElement = null;\n      this.onPointerDown = null;\n      this.processPointerDown = null;\n      this.onPointerUp = null;\n      this.processPointerUp = null;\n      this.onPointerCancel = null;\n      this.processPointerCancel = null;\n      this.onPointerMove = null;\n      this.processPointerMove = null;\n      this.onPointerOut = null;\n      this.processPointerOverOut = null;\n      this.onPointerOver = null;\n      this._tempPoint = null;\n    }\n  }]);\n  return InteractionLayer;\n}(EventDispatcher);\n\n(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function (callback) {\n      var currTime = new Date().getTime();\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      var id = window.setTimeout(function () {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function (id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n/**\n * @extends EventDispatcher\n */\n\n\nvar Ticker = function (_EventDispatcher) {\n  inherits(Ticker, _EventDispatcher);\n  /**\n   *\n   */\n\n  function Ticker() {\n    classCallCheck(this, Ticker);\n\n    var _this = possibleConstructorReturn(this, (Ticker.__proto__ || Object.getPrototypeOf(Ticker)).call(this));\n\n    _this.timer = null;\n    _this.started = false;\n    /**\n     * pre-time cache\n     *\n     * @member {Number}\n     * @private\n     */\n\n    _this.pt = 0;\n    /**\n     * how long the time through, at this tick\n     *\n     * @member {Number}\n     * @private\n     */\n\n    _this.snippet = 0;\n\n    _this.start();\n\n    return _this;\n  }\n  /**\n   * start tick loop\n   */\n\n\n  createClass(Ticker, [{\n    key: 'start',\n    value: function start() {\n      var _this2 = this;\n\n      if (this.started) return;\n\n      var loop = function loop() {\n        _this2.timeline();\n\n        _this2.emit('tick', {\n          snippet: _this2.snippet\n        });\n\n        _this2.timer = RAF(loop);\n      };\n\n      loop();\n    }\n    /**\n     * stop tick loop\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      CAF(this.timer);\n      this.started = false;\n    }\n    /**\n     * get timeline snippet\n     *\n     * @private\n     */\n\n  }, {\n    key: 'timeline',\n    value: function timeline() {\n      this.snippet = Date.now() - this.pt;\n\n      if (this.pt === 0 || this.snippet > 200) {\n        this.pt = Date.now();\n        this.snippet = Date.now() - this.pt;\n      }\n\n      this.pt += this.snippet;\n    }\n  }]);\n  return Ticker;\n}(EventDispatcher);\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * import { Interaction } from 'three.interaction';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interaction = new Interaction(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on ...\n *\n * // you can also listen on parent-node or any display-tree node,\n * // source event will bubble up along with display-tree.\n * // you can stop the bubble-up by invoke ev.stopPropagation function.\n * scene.on('touchstart', ev => {\n *   console.log(ev);\n * })\n *\n * @class\n * @extends InteractionManager\n */\n\n\nvar Interaction = function (_InteractionManager) {\n  inherits(Interaction, _InteractionManager);\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n\n  function Interaction(renderer, scene, camera, options) {\n    classCallCheck(this, Interaction);\n    options = Object.assign({\n      autoAttach: false\n    }, options);\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n\n    var _this = possibleConstructorReturn(this, (Interaction.__proto__ || Object.getPrototypeOf(Interaction)).call(this, renderer, scene, camera, options));\n\n    _this.ticker = new Ticker();\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n\n    _this.update = _this.update.bind(_this);\n\n    _this.on('addevents', function () {\n      _this.ticker.on('tick', _this.update);\n    });\n\n    _this.on('removeevents', function () {\n      _this.ticker.off('tick', _this.update);\n    });\n\n    _this.setTargetElement(_this.renderer.domElement);\n\n    return _this;\n  }\n\n  return Interaction;\n}(InteractionManager);\n\nexport { InteractionManager, InteractionLayer, Interaction };","map":null,"metadata":{},"sourceType":"module"}