{"ast":null,"code":"import React, { useState, useEffect, useRef } from 'react';\nimport { scaleLinear } from 'd3-scale';\nimport { Tween, Easing, update } from 'es6-tween';\nimport { TextureLoader, SphereGeometry, MeshLambertMaterial, MeshBasicMaterial, BackSide, Color, Mesh, BoxGeometry, Vector3, WebGLRenderer, PerspectiveCamera, AmbientLight, PointLight, Group, Scene } from 'three';\nimport { createGlowMesh } from 'three-glow-mesh';\nimport OrbitControls from 'three-orbitcontrols';\nimport { Interaction } from 'three.interaction';\nimport tippy from 'tippy.js';\nimport ResizeObserver from 'resize-observer-polyfill';\nvar ObjectName;\n\n(function (ObjectName) {\n  ObjectName[\"Camera\"] = \"CAMERA\";\n  ObjectName[\"CameraAmbientLight\"] = \"CAMERA_AMBIENT_LIGHT\";\n  ObjectName[\"CameraPointLight\"] = \"CAMERA_POINT_LIGHT\";\n  ObjectName[\"Globe\"] = \"GLOBE\";\n  ObjectName[\"GlobeBackground\"] = \"GLOBE_BACKGROUND\";\n  ObjectName[\"GlobeClouds\"] = \"GLOBE_CLOUDS\";\n  ObjectName[\"GlobeGlow\"] = \"GLOBE_GLOW\";\n  ObjectName[\"GlobeSphere\"] = \"GLOBE_SPHERE\";\n  ObjectName[\"MarkerObjects\"] = \"MARKER_OBJECTS\";\n  ObjectName[\"Scene\"] = \"SCENE\";\n})(ObjectName || (ObjectName = {}));\n\nvar MarkerType;\n\n(function (MarkerType) {\n  MarkerType[\"Bar\"] = \"bar\";\n  MarkerType[\"Dot\"] = \"dot\";\n})(MarkerType || (MarkerType = {})); // hardcoded constants that can eventually be exposed via options\n\n\nvar RADIUS = 300;\nvar BACKGROUND_RADIUS_SCALE = 10;\nvar CAMERA_FAR = RADIUS * 100;\nvar CAMERA_FOV = 45;\nvar CAMERA_NEAR = 1;\nvar CAMERA_DAMPING_FACTOR = 0.1;\nvar CAMERA_MAX_POLAR_ANGLE = Math.PI;\nvar CAMERA_MIN_POLAR_ANGLE = 0;\nvar CAMERA_MIN_DISTANCE_RADIUS_SCALE = 1.1;\nvar CLOUDS_RADIUS_OFFSET = 1;\nvar GLOBE_SEGMENTS = 50;\nvar INITIAL_COORDINATES = [37.773972, -122.431297];\nvar MARKER_DEFAULT_COLOR = 'gold';\nvar MARKER_SEGMENTS = 10;\nvar MARKER_UNIT_RADIUS_SCALE = 0.01;\nvar MARKER_ACTIVE_ANIMATION_DURATION = 100;\nvar MARKER_ACTIVE_ANIMATION_EASING_FUNCTION = ['Cubic', 'In'];\nvar defaultCameraOptions = {\n  autoRotateSpeed: 0.1,\n  distanceRadiusScale: 3,\n  enableAutoRotate: true,\n  enableRotate: true,\n  enableZoom: true,\n  maxDistanceRadiusScale: 4,\n  maxPolarAngle: CAMERA_MAX_POLAR_ANGLE,\n  minPolarAngle: CAMERA_MIN_POLAR_ANGLE,\n  rotateSpeed: 0.2,\n  zoomSpeed: 1\n};\nvar defaultFocusOptions = {\n  animationDuration: 1000,\n  distanceRadiusScale: 1.5,\n  easingFunction: ['Cubic', 'Out'],\n  enableDefocus: true\n};\nvar defaultGlobeOptions = {\n  backgroundTexture: 'https://raw.githubusercontent.com/chrisrzhou/react-globe/master/textures/background.png',\n  cloudsOpacity: 0.3,\n  cloudsTexture: 'https://raw.githubusercontent.com/chrisrzhou/react-globe/master/textures/clouds.png',\n  enableBackground: true,\n  enableClouds: true,\n  enableGlow: true,\n  glowCoefficient: 0.1,\n  glowColor: '#d1d1d1',\n  glowPower: 3,\n  glowRadiusScale: 0.2,\n  texture: 'https://raw.githubusercontent.com/chrisrzhou/react-globe/master/textures/globe.jpg'\n};\nvar defaultLightOptions = {\n  ambientLightColor: 'white',\n  ambientLightIntensity: 0.8,\n  pointLightColor: 'white',\n  pointLightIntensity: 1,\n  pointLightPositionRadiusScales: [-2, 1, -1]\n};\nvar defaultDotMarkerOptions = {\n  activeScale: 1.3,\n  enableGlow: true,\n  enableTooltip: true,\n  enterAnimationDuration: 1000,\n  enterEasingFunction: ['Linear', 'None'],\n  exitAnimationDuration: 500,\n  exitEasingFunction: ['Cubic', 'Out'],\n  getTooltipContent: function (marker) {\n    return JSON.stringify(marker.coordinates);\n  },\n  glowCoefficient: 0,\n  glowPower: 3,\n  glowRadiusScale: 2,\n  radiusScaleRange: [0.005, 0.02],\n  type: MarkerType.Dot\n};\nvar defaultBarMarkerOptions = {\n  activeScale: 1.02,\n  enableGlow: false,\n  enableTooltip: true,\n  enterAnimationDuration: 2000,\n  enterEasingFunction: ['Linear', 'None'],\n  exitAnimationDuration: 1000,\n  exitEasingFunction: ['Cubic', 'Out'],\n  getTooltipContent: function (marker) {\n    return JSON.stringify(marker.coordinates);\n  },\n  glowCoefficient: 0,\n  glowPower: 3,\n  glowRadiusScale: 2,\n  offsetRadiusScale: 0,\n  radiusScaleRange: [0.2, defaultFocusOptions.distanceRadiusScale - 1],\n  type: MarkerType.Bar\n};\nvar defaultMarkerOptions = defaultDotMarkerOptions;\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n}\n\nvar TOOLTIP_OFFSET = 10;\n\nvar Tooltip =\n/** @class */\nfunction () {\n  function Tooltip(div) {\n    this.div = div;\n    this.instance = tippy(this.div, {\n      animation: 'scale'\n    });\n  }\n\n  Tooltip.prototype.destroy = function () {\n    this.instance.destroy();\n  };\n\n  Tooltip.prototype.hide = function () {\n    document.body.style.cursor = 'inherit';\n    this.div.style.position = 'fixed';\n    this.div.style.left = '0';\n    this.div.style.top = '0';\n    this.instance.hide();\n  };\n\n  Tooltip.prototype.show = function (clientX, clientY, content) {\n    document.body.style.cursor = 'pointer';\n    this.div.style.position = 'fixed';\n    this.div.style.left = clientX + TOOLTIP_OFFSET + \"px\";\n    this.div.style.top = clientY + TOOLTIP_OFFSET + \"px\";\n    this.instance.setContent(content);\n    this.instance.show();\n  };\n\n  return Tooltip;\n}();\n\nfunction coordinatesToPosition(coordinates, radius) {\n  var lat = coordinates[0],\n      long = coordinates[1];\n  var phi = lat * Math.PI / 180;\n  var theta = (long - 180) * Math.PI / 180;\n  var x = -radius * Math.cos(phi) * Math.cos(theta);\n  var y = radius * Math.sin(phi);\n  var z = radius * Math.cos(phi) * Math.sin(theta);\n  return [x, y, z];\n}\n\nfunction getMarkerCoordinatesKey(marker) {\n  return marker.coordinates.toString();\n}\n\nfunction maxValue(array, callback) {\n  var maxValue = 0;\n  array.forEach(function (item) {\n    if (callback(item) > maxValue) {\n      maxValue = callback(item);\n    }\n  });\n  return maxValue;\n}\n\nfunction minValue(array, callback) {\n  var minValue = Infinity;\n  array.forEach(function (item) {\n    if (callback(item) < minValue) {\n      minValue = callback(item);\n    }\n  });\n  return minValue;\n}\n\nfunction tween(from, to, animationDuration, easingFunction, onUpdate, onEnd) {\n  new Tween(from).to(to, animationDuration).easing(Easing[easingFunction[0]][easingFunction[1]]).on('update', onUpdate).on('complete', onEnd).start();\n}\n\nvar emptyFunction = function () {};\n\nvar defaultCallbacks = {\n  onClickMarker: emptyFunction,\n  onDefocus: emptyFunction,\n  onMouseOutMarker: emptyFunction,\n  onMouseOverMarker: emptyFunction,\n  onTextureLoaded: emptyFunction\n};\nvar defaultOptions = {\n  camera: defaultCameraOptions,\n  globe: defaultGlobeOptions,\n  focus: defaultFocusOptions,\n  marker: defaultMarkerOptions,\n  light: defaultLightOptions\n};\n\nvar Globe =\n/** @class */\nfunction () {\n  function Globe(canvas, tooltipDiv) {\n    var _this = this; // create objects\n\n\n    var renderer = new WebGLRenderer({\n      alpha: true,\n      antialias: true,\n      canvas: canvas\n    });\n    var camera = new PerspectiveCamera();\n    var cameraAmbientLight = new AmbientLight('white');\n    var cameraPointLight = new PointLight('white');\n    var globe = new Group();\n    var globeBackground = new Mesh();\n    var globeClouds = new Mesh();\n    var globeSphere = new Mesh();\n    var markerObjects = new Group();\n    var orbitControls = new OrbitControls(camera, renderer.domElement);\n    var scene = new Scene();\n    var tooltip = new Tooltip(tooltipDiv); // name objects\n\n    camera.name = ObjectName.Camera;\n    cameraAmbientLight.name = ObjectName.CameraAmbientLight;\n    cameraPointLight.name = ObjectName.CameraPointLight;\n    globe.name = ObjectName.Globe;\n    globeBackground.name = ObjectName.GlobeBackground;\n    globeClouds.name = ObjectName.GlobeClouds;\n    globeSphere.name = ObjectName.GlobeSphere;\n    markerObjects.name = ObjectName.MarkerObjects;\n    scene.name = ObjectName.Scene; // add objects to scene\n\n    camera.add(cameraAmbientLight);\n    camera.add(cameraPointLight);\n    globe.add(globeBackground);\n    globe.add(globeClouds);\n    globe.add(globeSphere);\n    scene.add(markerObjects);\n    scene.add(camera);\n    scene.add(globe); // add interactions to scene\n\n    new Interaction(renderer, scene, camera);\n    scene.on('mousemove', function (event) {\n      if (_this.isFocusing()) {\n        return;\n      }\n\n      if (_this.activeMarker) {\n        var activeScale = _this.options.marker.activeScale;\n        var from_1 = [activeScale, activeScale, activeScale];\n        tween(from_1, [1, 1, 1], MARKER_ACTIVE_ANIMATION_DURATION, MARKER_ACTIVE_ANIMATION_EASING_FUNCTION, function () {\n          var _a;\n\n          if (_this.activeMarkerObject) {\n            (_a = _this.activeMarkerObject.scale).set.apply(_a, from_1);\n          }\n        }, function () {\n          _this.activeMarker = undefined;\n          _this.activeMarkerObject = undefined;\n        });\n\n        _this.callbacks.onMouseOutMarker(_this.activeMarker, _this.activeMarkerObject, event.data.originalEvent);\n\n        _this.tooltip.hide();\n      }\n    });\n    scene.on('click', function (event) {\n      if (_this.isFocusing()) {\n        return;\n      }\n\n      if (_this.options.focus.enableDefocus && _this.preFocusPosition) {\n        _this.callbacks.onDefocus(_this.focus, event.data.originalEvent);\n\n        _this.updateFocus(undefined, _this.options.focus);\n      }\n    }); // assign values to class variables\n\n    this.activeMarker = undefined;\n    this.activeMarkerObject = undefined;\n    this.animationFrameId = undefined;\n    this.callbacks = defaultCallbacks;\n    this.camera = camera;\n    this.focus = undefined;\n    this.globe = globe;\n    this.isFrozen = false;\n    this.markerObjects = markerObjects;\n    this.options = defaultOptions;\n    this.orbitControls = orbitControls;\n    this.preFocusPosition = undefined;\n    this.renderer = renderer;\n    this.scene = scene;\n    this.tooltip = tooltip; // update objects\n\n    this.updateCallbacks();\n    this.updateCamera();\n    this.updateFocus();\n    this.updateGlobe({\n      enableBackground: false,\n      enableClouds: false\n    });\n    this.updateLights();\n    this.updateMarkers();\n    this.updateSize();\n  }\n\n  Globe.prototype.animate = function () {\n    this.render();\n    this.animationFrameId = requestAnimationFrame(this.animate.bind(this));\n  }; // TODO: expose a way to customize animating clouds in every axis\n\n\n  Globe.prototype.animateClouds = function () {\n    var globeClouds = this.getObjectByName(ObjectName.GlobeClouds);\n    ['x', 'y', 'z'].forEach(function (axis) {\n      globeClouds.rotation[axis] += Math.random() / 10000;\n    });\n  }; // For each animation, update the focus and focusOptions provided by the animation over an array of timeouts\n\n\n  Globe.prototype.applyAnimations = function (animations) {\n    var _this = this;\n\n    var currentFocus = this.focus;\n    var currentFocusOptions = this.options.focus;\n    var wait = 0;\n    var timeouts = [];\n    animations.forEach(function (animation) {\n      var animationDuration = animation.animationDuration,\n          coordinates = animation.coordinates,\n          distanceRadiusScale = animation.distanceRadiusScale,\n          easingFunction = animation.easingFunction;\n      var timeout = setTimeout(function () {\n        _this.updateFocus(coordinates, {\n          animationDuration: animationDuration,\n          distanceRadiusScale: distanceRadiusScale,\n          easingFunction: easingFunction\n        }, true);\n      }, wait);\n      timeouts.push(timeout);\n      wait += animationDuration;\n    }); // return cleanup function\n\n    return function () {\n      timeouts.forEach(function (timeout) {\n        clearTimeout(timeout);\n      });\n\n      _this.updateFocus(currentFocus, currentFocusOptions);\n    };\n  };\n\n  Globe.prototype.destroy = function () {\n    cancelAnimationFrame(this.animationFrameId);\n    this.tooltip.destroy();\n  };\n\n  Globe.prototype.enableOrbitControls = function (enabled, autoRotate) {\n    if (autoRotate === void 0) {\n      autoRotate = enabled;\n    }\n\n    this.orbitControls.enabled = enabled;\n    this.orbitControls.autoRotate = autoRotate;\n  };\n\n  Globe.prototype.freeze = function () {\n    this.isFrozen = true;\n    this.enableOrbitControls(false);\n    cancelAnimationFrame(this.animationFrameId);\n  };\n\n  Globe.prototype.getObjectByName = function (name) {\n    return this.scene.getObjectByName(name);\n  };\n\n  Globe.prototype.isFocusing = function () {\n    return !this.orbitControls.enabled;\n  };\n\n  Globe.prototype.render = function () {\n    this.renderer.sortObjects = false;\n    this.renderer.render(this.scene, this.camera);\n    this.animateClouds();\n    this.orbitControls.update();\n    update();\n  };\n\n  Globe.prototype.updateCallbacks = function (callbacks) {\n    var _this = this;\n\n    if (callbacks === void 0) {\n      callbacks = {};\n    }\n\n    Object.keys(defaultCallbacks).forEach(function (key) {\n      _this.callbacks[key] = callbacks[key] || defaultCallbacks[key];\n    });\n  };\n\n  Globe.prototype.updateCamera = function (initialCoordinates, cameraOptions) {\n    if (initialCoordinates === void 0) {\n      initialCoordinates = INITIAL_COORDINATES;\n    }\n\n    if (cameraOptions === void 0) {\n      cameraOptions = {};\n    }\n\n    this.updateOptions(cameraOptions, 'camera');\n    var _a = this.options.camera,\n        autoRotateSpeed = _a.autoRotateSpeed,\n        distanceRadiusScale = _a.distanceRadiusScale,\n        enableAutoRotate = _a.enableAutoRotate,\n        enableRotate = _a.enableRotate,\n        enableZoom = _a.enableZoom,\n        maxDistanceRadiusScale = _a.maxDistanceRadiusScale,\n        maxPolarAngle = _a.maxPolarAngle,\n        minPolarAngle = _a.minPolarAngle,\n        rotateSpeed = _a.rotateSpeed,\n        zoomSpeed = _a.zoomSpeed;\n\n    if (this.initialCoordinates !== initialCoordinates) {\n      var _b = coordinatesToPosition(initialCoordinates, RADIUS * distanceRadiusScale),\n          x = _b[0],\n          y = _b[1],\n          z = _b[2];\n\n      this.camera.position.set(x, y, z);\n      this.initialCoordinates = initialCoordinates;\n    }\n\n    this.camera.far = CAMERA_FAR;\n    this.camera.fov = CAMERA_FOV;\n    this.camera.near = CAMERA_NEAR;\n    this.orbitControls.autoRotate = enableAutoRotate;\n    this.orbitControls.autoRotateSpeed = autoRotateSpeed;\n    this.orbitControls.dampingFactor = CAMERA_DAMPING_FACTOR;\n    this.orbitControls.enableDamping = true;\n    this.orbitControls.enablePan = false;\n    this.orbitControls.enableRotate = enableRotate;\n    this.orbitControls.enableZoom = enableZoom;\n    this.orbitControls.maxDistance = RADIUS * maxDistanceRadiusScale;\n    this.orbitControls.maxPolarAngle = maxPolarAngle;\n    this.orbitControls.minDistance = RADIUS * CAMERA_MIN_DISTANCE_RADIUS_SCALE;\n    this.orbitControls.minPolarAngle = minPolarAngle;\n    this.orbitControls.rotateSpeed = rotateSpeed;\n    this.orbitControls.zoomSpeed = zoomSpeed;\n  };\n\n  Globe.prototype.updateFocus = function (focus, focusOptions, autoDefocus) {\n    var _this = this;\n\n    if (focusOptions === void 0) {\n      focusOptions = {};\n    }\n\n    if (autoDefocus === void 0) {\n      autoDefocus = false;\n    }\n\n    this.updateOptions(focusOptions, 'focus');\n    this.focus = focus;\n    var _a = this.options.focus,\n        animationDuration = _a.animationDuration,\n        distanceRadiusScale = _a.distanceRadiusScale,\n        easingFunction = _a.easingFunction;\n\n    if (this.isFrozen) {\n      return;\n    }\n\n    if (this.focus) {\n      // disable orbit controls when focused\n      var from_2 = [this.camera.position.x, this.camera.position.y, this.camera.position.z];\n      var to = coordinatesToPosition(this.focus, RADIUS * distanceRadiusScale);\n      this.preFocusPosition = this.preFocusPosition || __spreadArrays(from_2);\n      tween(from_2, to, animationDuration, easingFunction, function () {\n        var _a;\n\n        _this.enableOrbitControls(false);\n\n        (_a = _this.camera.position).set.apply(_a, from_2);\n      }, function () {\n        if (autoDefocus) {\n          _this.focus = undefined;\n          _this.preFocusPosition = undefined;\n        }\n\n        _this.enableOrbitControls(true, autoDefocus);\n      });\n    } else {\n      if (this.preFocusPosition) {\n        var from_3 = [this.camera.position.x, this.camera.position.y, this.camera.position.z];\n        var to = this.preFocusPosition;\n        tween(from_3, to, animationDuration, easingFunction, function () {\n          var _a;\n\n          _this.enableOrbitControls(false);\n\n          (_a = _this.camera.position).set.apply(_a, from_3);\n        }, function () {\n          _this.preFocusPosition = undefined;\n\n          _this.enableOrbitControls(true);\n        });\n      }\n    }\n  };\n\n  Globe.prototype.updateGlobe = function (globeOptions) {\n    var _this = this;\n\n    if (globeOptions === void 0) {\n      globeOptions = {};\n    }\n\n    this.updateOptions(globeOptions, 'globe');\n    var _a = this.options.globe,\n        backgroundTexture = _a.backgroundTexture,\n        cloudsOpacity = _a.cloudsOpacity,\n        cloudsTexture = _a.cloudsTexture,\n        enableBackground = _a.enableBackground,\n        enableClouds = _a.enableClouds,\n        enableGlow = _a.enableGlow,\n        glowColor = _a.glowColor,\n        glowCoefficient = _a.glowCoefficient,\n        glowPower = _a.glowPower,\n        glowRadiusScale = _a.glowRadiusScale,\n        texture = _a.texture;\n    var globeBackground = this.getObjectByName(ObjectName.GlobeBackground);\n    var globeClouds = this.getObjectByName(ObjectName.GlobeClouds);\n    var globeSphere = this.getObjectByName(ObjectName.GlobeSphere);\n    new TextureLoader().load(texture, function (map) {\n      globeSphere.geometry = new SphereGeometry(RADIUS, GLOBE_SEGMENTS, GLOBE_SEGMENTS);\n      globeSphere.material = new MeshLambertMaterial({\n        map: map\n      });\n\n      if (enableGlow) {\n        globeSphere.remove(_this.getObjectByName(ObjectName.GlobeGlow));\n        var globeGlow = createGlowMesh(globeSphere.geometry, {\n          backside: true,\n          color: glowColor,\n          coefficient: glowCoefficient,\n          power: glowPower,\n          size: RADIUS * glowRadiusScale\n        });\n        globeGlow.name = ObjectName.GlobeGlow;\n        globeSphere.add(globeGlow);\n      }\n\n      _this.callbacks.onTextureLoaded();\n    });\n\n    if (enableBackground) {\n      new TextureLoader().load(backgroundTexture, function (map) {\n        globeBackground.geometry = new SphereGeometry(RADIUS * BACKGROUND_RADIUS_SCALE, GLOBE_SEGMENTS, GLOBE_SEGMENTS);\n        globeBackground.material = new MeshBasicMaterial({\n          map: map,\n          side: BackSide\n        });\n      });\n    }\n\n    if (enableClouds) {\n      new TextureLoader().load(cloudsTexture, function (map) {\n        globeClouds.geometry = new SphereGeometry(RADIUS + CLOUDS_RADIUS_OFFSET, GLOBE_SEGMENTS, GLOBE_SEGMENTS);\n        globeClouds.material = new MeshLambertMaterial({\n          map: map,\n          transparent: true\n        });\n        globeClouds.material.opacity = cloudsOpacity;\n      });\n    }\n  };\n\n  Globe.prototype.updateLights = function (lightOptions) {\n    if (lightOptions === void 0) {\n      lightOptions = {};\n    }\n\n    this.updateOptions(lightOptions, 'light');\n    var _a = this.options.light,\n        ambientLightColor = _a.ambientLightColor,\n        ambientLightIntensity = _a.ambientLightIntensity,\n        pointLightColor = _a.pointLightColor,\n        pointLightIntensity = _a.pointLightIntensity,\n        pointLightPositionRadiusScales = _a.pointLightPositionRadiusScales;\n    var cameraAmbientLight = this.getObjectByName(ObjectName.CameraAmbientLight);\n    var cameraPointLight = this.getObjectByName(ObjectName.CameraPointLight);\n    cameraAmbientLight.color = new Color(ambientLightColor);\n    cameraAmbientLight.intensity = ambientLightIntensity;\n    cameraPointLight.color = new Color(pointLightColor);\n    cameraPointLight.intensity = pointLightIntensity;\n    cameraPointLight.position.set(RADIUS * pointLightPositionRadiusScales[0], RADIUS * pointLightPositionRadiusScales[1], RADIUS * pointLightPositionRadiusScales[2]);\n  };\n\n  Globe.prototype.updateMarkers = function (markers, markerOptions) {\n    var _this = this;\n\n    if (markers === void 0) {\n      markers = [];\n    }\n\n    if (markerOptions === void 0) {\n      markerOptions = {};\n    }\n\n    this.updateOptions(markerOptions, 'marker');\n    var _a = this.options.marker,\n        activeScale = _a.activeScale,\n        enableGlow = _a.enableGlow,\n        enableTooltip = _a.enableTooltip,\n        enterAnimationDuration = _a.enterAnimationDuration,\n        enterEasingFunction = _a.enterEasingFunction,\n        exitAnimationDuration = _a.exitAnimationDuration,\n        exitEasingFunction = _a.exitEasingFunction,\n        getTooltipContent = _a.getTooltipContent,\n        glowCoefficient = _a.glowCoefficient,\n        glowPower = _a.glowPower,\n        glowRadiusScale = _a.glowRadiusScale,\n        offsetRadiusScale = _a.offsetRadiusScale,\n        radiusScaleRange = _a.radiusScaleRange,\n        renderer = _a.renderer,\n        type = _a.type;\n    var unitRadius = RADIUS * MARKER_UNIT_RADIUS_SCALE;\n    var sizeScale = scaleLinear().domain([minValue(markers, function (marker) {\n      return marker.value;\n    }), maxValue(markers, function (marker) {\n      return marker.value;\n    })]).range([RADIUS * radiusScaleRange[0], RADIUS * radiusScaleRange[1]]);\n    var markerCoordinatesKeys = new Set(markers.map(getMarkerCoordinatesKey));\n    var markerObjectNames = new Set(this.markerObjects.children.map(function (markerObject) {\n      return markerObject.name;\n    }));\n    markers.forEach(function (marker) {\n      var _a;\n\n      var coordinates = marker.coordinates,\n          value = marker.value;\n      var markerCoordinatesKey = getMarkerCoordinatesKey(marker);\n      var size = sizeScale(value);\n      var markerObject; // create new marker objects\n\n      if (!markerObjectNames.has(markerCoordinatesKey)) {\n        if (renderer !== undefined) {\n          markerObject = renderer(marker);\n        } else {\n          var color_1 = marker.color || MARKER_DEFAULT_COLOR;\n          var from_4 = {\n            size: 0\n          };\n          var to = {\n            size: size\n          };\n          var mesh_1 = new Mesh();\n          tween(from_4, to, enterAnimationDuration, enterEasingFunction, function () {\n            switch (type) {\n              case MarkerType.Bar:\n                mesh_1.geometry = new BoxGeometry(unitRadius, unitRadius, from_4.size);\n                mesh_1.material = new MeshLambertMaterial({\n                  color: color_1\n                });\n                break;\n\n              case MarkerType.Dot:\n              default:\n                mesh_1.geometry = new SphereGeometry(from_4.size, MARKER_SEGMENTS, MARKER_SEGMENTS);\n                mesh_1.material = new MeshBasicMaterial({\n                  color: color_1\n                });\n\n                if (enableGlow) {\n                  // add glow\n                  var glowMesh = createGlowMesh(mesh_1.geometry.clone(), {\n                    backside: false,\n                    color: color_1,\n                    coefficient: glowCoefficient,\n                    power: glowPower,\n                    size: from_4.size * glowRadiusScale\n                  });\n                  mesh_1.children = [];\n                  mesh_1.add(glowMesh);\n                }\n\n            }\n          });\n          markerObject = mesh_1;\n        } // place markers\n\n\n        var heightOffset = 0;\n\n        if (offsetRadiusScale !== undefined) {\n          heightOffset = RADIUS * offsetRadiusScale;\n        } else {\n          if (type === MarkerType.Dot) {\n            heightOffset = size * (1 + glowRadiusScale) / 2;\n          } else {\n            heightOffset = 0;\n          }\n        }\n\n        var position = coordinatesToPosition(coordinates, RADIUS + heightOffset);\n\n        (_a = markerObject.position).set.apply(_a, position);\n\n        markerObject.lookAt(new Vector3(0, 0, 0));\n        markerObject.name = markerCoordinatesKey;\n\n        _this.markerObjects.add(markerObject);\n      } // update existing marker objects\n\n\n      markerObject = _this.markerObjects.getObjectByName(markerCoordinatesKey);\n\n      var handleClick = function (event) {\n        event.stopPropagation();\n\n        _this.updateFocus(marker.coordinates);\n\n        _this.callbacks.onClickMarker(marker, markerObject, event.data.originalEvent);\n      };\n\n      markerObject.on('click', handleClick.bind(_this));\n      markerObject.on('touchstart', handleClick.bind(_this));\n      markerObject.on('mousemove', function (event) {\n        if (_this.isFocusing()) {\n          _this.tooltip.hide();\n\n          return;\n        }\n\n        event.stopPropagation();\n        var from = markerObject.scale.toArray();\n        tween(from, [activeScale, activeScale, activeScale], MARKER_ACTIVE_ANIMATION_DURATION, MARKER_ACTIVE_ANIMATION_EASING_FUNCTION, function () {\n          var _a;\n\n          if (markerObject) {\n            (_a = markerObject.scale).set.apply(_a, from);\n          }\n        });\n        var originalEvent = event.data.originalEvent;\n        _this.activeMarker = marker;\n        _this.activeMarkerObject = markerObject;\n\n        _this.callbacks.onMouseOverMarker(marker, markerObject, originalEvent);\n\n        if (enableTooltip) {\n          _this.tooltip.show(originalEvent.clientX, originalEvent.clientY, getTooltipContent(marker));\n        }\n      });\n    }); // remove marker objects that are stale\n\n    var markerObjectsToRemove = this.markerObjects.children.filter(function (markerObject) {\n      return !markerCoordinatesKeys.has(markerObject.name);\n    });\n    markerObjectsToRemove.forEach(function (markerObject) {\n      var from = markerObject.scale.toArray();\n      tween(from, [0, 0, 0], exitAnimationDuration, exitEasingFunction, function () {\n        var _a;\n\n        if (markerObject) {\n          (_a = markerObject.scale).set.apply(_a, from);\n        }\n      }, function () {\n        _this.markerObjects.remove(markerObject);\n      });\n    });\n  };\n\n  Globe.prototype.updateOptions = function (options, key) {\n    var _a;\n\n    this.options = __assign(__assign({}, defaultOptions), (_a = {}, _a[key] = __assign(__assign({}, defaultOptions[key]), options), _a));\n  };\n\n  Globe.prototype.updateSize = function (size) {\n    if (size) {\n      var width = size[0],\n          height = size[1];\n      this.renderer.setSize(width, height);\n      this.camera.aspect = width / height;\n    }\n\n    this.camera.updateProjectionMatrix();\n  };\n\n  Globe.prototype.unfreeze = function () {\n    if (this.isFrozen) {\n      this.isFrozen = false;\n      this.enableOrbitControls(true);\n      this.animate();\n    }\n  };\n\n  return Globe;\n}();\n\nfunction useResize(mountRef, initialSize) {\n  var _a = useState([0, 0]),\n      size = _a[0],\n      setSize = _a[1];\n\n  useEffect(function () {\n    var mount = mountRef.current; // update initial size\n\n    var width = 0;\n    var height = 0;\n\n    if (initialSize) {\n      // Use initialSize if it is provided\n      width = initialSize[0], height = initialSize[1];\n    } else {\n      // Use parentElement size if resized has not updated\n      width = mount.offsetWidth;\n      height = mount.offsetHeight;\n    }\n\n    setSize([width, height]); // update resize using a resize observer\n\n    var resizeObserver = new ResizeObserver(function (entries) {\n      if (!entries || !entries.length) {\n        return;\n      }\n\n      if (initialSize === undefined) {\n        var _a = entries[0].contentRect,\n            width_1 = _a.width,\n            height_1 = _a.height;\n        setSize([width_1, height_1]);\n      }\n    });\n    resizeObserver.observe(mount);\n    return function () {\n      resizeObserver.unobserve(mount);\n    };\n  }, [initialSize, mountRef]);\n  return size;\n}\n\nfunction ReactGlobe(_a) {\n  var animations = _a.animations,\n      cameraOptions = _a.cameraOptions,\n      focus = _a.focus,\n      focusOptions = _a.focusOptions,\n      globeOptions = _a.globeOptions,\n      lightOptions = _a.lightOptions,\n      initialCoordinates = _a.initialCoordinates,\n      markers = _a.markers,\n      markerOptions = _a.markerOptions,\n      onClickMarker = _a.onClickMarker,\n      onDefocus = _a.onDefocus,\n      onMouseOutMarker = _a.onMouseOutMarker,\n      onMouseOverMarker = _a.onMouseOverMarker,\n      onGetGlobeInstance = _a.onGetGlobeInstance,\n      onTextureLoaded = _a.onTextureLoaded,\n      initialSize = _a.size;\n  var canvasRef = useRef();\n  var globeInstanceRef = useRef();\n  var mountRef = useRef();\n  var tooltipRef = useRef();\n  var size = useResize(mountRef, initialSize); // init\n\n  useEffect(function () {\n    var mount = mountRef.current;\n    var globeInstance = new Globe(canvasRef.current, tooltipRef.current);\n    mount.appendChild(globeInstance.renderer.domElement);\n    globeInstance.animate();\n    globeInstanceRef.current = globeInstance;\n    onGetGlobeInstance && onGetGlobeInstance(globeInstance);\n    return function () {\n      mount.removeChild(globeInstance.renderer.domElement);\n      globeInstance.destroy();\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // update callbacks\n\n  useEffect(function () {\n    globeInstanceRef.current.updateCallbacks({\n      onClickMarker: onClickMarker,\n      onDefocus: onDefocus,\n      onMouseOutMarker: onMouseOutMarker,\n      onMouseOverMarker: onMouseOverMarker,\n      onTextureLoaded: onTextureLoaded\n    });\n  }, [onClickMarker, onDefocus, onMouseOutMarker, onMouseOverMarker, onTextureLoaded]); // update camera\n\n  useEffect(function () {\n    globeInstanceRef.current.updateCamera(initialCoordinates, cameraOptions);\n  }, [cameraOptions, initialCoordinates]); // update focus\n\n  useEffect(function () {\n    globeInstanceRef.current.updateFocus(focus, focusOptions);\n  }, [focus, focusOptions]); // update globe\n\n  useEffect(function () {\n    globeInstanceRef.current.updateGlobe(globeOptions);\n  }, [globeOptions]); // update lights\n\n  useEffect(function () {\n    globeInstanceRef.current.updateLights(lightOptions);\n  }, [lightOptions]); // update markers\n\n  useEffect(function () {\n    globeInstanceRef.current.updateMarkers(markers, markerOptions);\n  }, [markerOptions, markers]); // apply animations\n\n  useEffect(function () {\n    return globeInstanceRef.current.applyAnimations(animations);\n  }, [animations]); // resize\n\n  useEffect(function () {\n    globeInstanceRef.current.updateSize(size);\n  }, [size]);\n  return React.createElement(\"div\", {\n    ref: mountRef,\n    style: {\n      height: '100%',\n      width: '100%'\n    }\n  }, React.createElement(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      display: 'block'\n    }\n  }), React.createElement(\"div\", {\n    ref: tooltipRef\n  }));\n}\n\nReactGlobe.defaultProps = {\n  animations: [],\n  cameraOptions: defaultCameraOptions,\n  focusOptions: defaultFocusOptions,\n  globeOptions: defaultGlobeOptions,\n  lightOptions: defaultLightOptions,\n  initialCoordinates: INITIAL_COORDINATES,\n  markers: [],\n  markerOptions: defaultMarkerOptions\n};\nexport default ReactGlobe;\nexport { BACKGROUND_RADIUS_SCALE, CAMERA_DAMPING_FACTOR, CAMERA_FAR, CAMERA_FOV, CAMERA_MAX_POLAR_ANGLE, CAMERA_MIN_DISTANCE_RADIUS_SCALE, CAMERA_MIN_POLAR_ANGLE, CAMERA_NEAR, CLOUDS_RADIUS_OFFSET, GLOBE_SEGMENTS, Globe, INITIAL_COORDINATES, MARKER_ACTIVE_ANIMATION_DURATION, MARKER_ACTIVE_ANIMATION_EASING_FUNCTION, MARKER_DEFAULT_COLOR, MARKER_SEGMENTS, MARKER_UNIT_RADIUS_SCALE, MarkerType, ObjectName, RADIUS, Tooltip, coordinatesToPosition, defaultBarMarkerOptions, defaultCameraOptions, defaultDotMarkerOptions, defaultFocusOptions, defaultGlobeOptions, defaultLightOptions, defaultMarkerOptions, getMarkerCoordinatesKey, maxValue, minValue, tween };","map":null,"metadata":{},"sourceType":"module"}