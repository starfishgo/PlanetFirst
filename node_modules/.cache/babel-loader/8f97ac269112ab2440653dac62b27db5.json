{"ast":null,"code":"import { ShaderMaterial, Color, Face3, BackSide, Mesh } from 'three';\nvar fragmentShader = \"\\nuniform vec3 color;\\nuniform float coefficient;\\nuniform float power;\\nvarying vec3 vVertexNormal;\\nvarying vec3 vVertexWorldPosition;\\nvoid main() {\\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\\n  vec3 viewCameraToVertex\\t= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\\n  viewCameraToVertex = normalize(viewCameraToVertex);\\n  float intensity\\t= pow(\\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\\n    power\\n  );\\n  gl_FragColor = vec4(color, intensity);\\n}\";\nvar vertexShader = \"\\nvarying vec3 vVertexWorldPosition;\\nvarying vec3 vVertexNormal;\\nvoid main() {\\n  vVertexNormal\\t= normalize(normalMatrix * normal);\\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\\n  gl_Position\\t= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\"; // Based off: http://stemkoski.blogspot.fr/2013/07/shaders-in-threejs-glow-and-halo.html\n\nfunction createGlowMaterial(coefficient, color, power) {\n  return new ShaderMaterial({\n    depthWrite: false,\n    fragmentShader: fragmentShader,\n    transparent: true,\n    uniforms: {\n      coefficient: {\n        type: 'f',\n        value: coefficient\n      },\n      color: {\n        type: 'c',\n        value: new Color(color)\n      },\n      power: {\n        type: 'f',\n        value: power\n      }\n    },\n    vertexShader: vertexShader\n  });\n}\n\nfunction createGlowGeometry(geometry, size) {\n  // gather vertexNormals from geometry.faces\n  var glowGeometry = geometry.clone();\n  var vertexNormals = new Array(glowGeometry.vertices.length);\n  glowGeometry.faces.forEach(function (face) {\n    if (face instanceof Face3) {\n      vertexNormals[face.a] = face.vertexNormals[0];\n      vertexNormals[face.b] = face.vertexNormals[1];\n      vertexNormals[face.c] = face.vertexNormals[2];\n    } else {\n      console.error('Face needs to be an instance of THREE.Face3.');\n    }\n  }); // modify the vertices according to vertexNormal\n\n  glowGeometry.vertices.forEach(function (vertex, i) {\n    var _a = vertexNormals[i],\n        x = _a.x,\n        y = _a.y,\n        z = _a.z;\n    vertex.x += x * size;\n    vertex.y += y * size;\n    vertex.z += z * size;\n  });\n  return glowGeometry;\n}\n\nvar defaultOptions = {\n  backside: true,\n  coefficient: 0.5,\n  color: 'gold',\n  size: 2,\n  power: 1\n};\n\nfunction createGlowMesh(geometry, options) {\n  if (options === void 0) {\n    options = defaultOptions;\n  }\n\n  var backside = options.backside,\n      coefficient = options.coefficient,\n      color = options.color,\n      size = options.size,\n      power = options.power;\n  var glowGeometry = createGlowGeometry(geometry, size);\n  var glowMaterial = createGlowMaterial(coefficient, color, power);\n\n  if (backside) {\n    glowMaterial.side = BackSide;\n  }\n\n  return new Mesh(glowGeometry, glowMaterial);\n}\n\nexport { createGlowGeometry, createGlowMaterial, createGlowMesh, defaultOptions };","map":null,"metadata":{},"sourceType":"module"}